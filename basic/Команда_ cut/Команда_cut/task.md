## Команда cut

Эта команда выполняет разбиение строк входящего потока на фрагменты; 
затем требуемые фрагменты собираются в строку и помещаются в исходящий поток.
Фрагментами могут быть байты, символы или построки, полученные делением строки по разделителям.

Формат команды:  
cut {  -b List [  -n ] |  -c List |  -f List [  -s ] [  -d Character ] } [ File ... ]  

File - путь_к_исходным_файлам  - опциональный параметр, если он не задан, используется стандартный поток ввода. 

**Список опции  (в скобках - вариант написания)**:  

Опции разбиения строки на байты или символы - элементы на заданных позициях попадут в строку вывода. 
**(счёт позиций выполняется с единицы)**:  

| опция | вариант написания         | описание                                                 |
|-------|---------------------------|----------------------------------------------------------|
| -b    | --bytes=LIST              | выбираемые набор или диапазон позиций байтов             |
| -n    |                           | "не склеивать" байты, являющиеся частями разных символов |  
| -     | -                         | -                                                        |
| -c    | --characters=LIST         | выбираемые набор или диапазон позиций символов           |  
| -     | -                         | -                                                        |
| -d    | --delimiter=DELIM         | разделитель полей (по умолчанию **TAB**)                 |
| -f    | --fields=LIST             | выбираемые набор или диапазон полей                      |                                
| -s    | --only-delimited          | не выводить строки без разделителя. (Только вместе с -f) | 
| -     | -                         | -                                                        |
|       | --complement              | избранные подстроки, остальное отфильтровывается         |  
|       | --output-delimiter=STRING | выходной разделитель, по умолчанию равен входному        |  
| -z    | --zero-terminated         | вместо символа новой строки разделителем будет **NULL**  |

 
Создадим файл example.txt, чтобы использовать перенос строк, используем для `echo` параметр `-e` и заключим текст в кавычки:

`echo -e "Winter: white: snow: frost\nSpring: green: grass: warm\nSummer: colorful: blossom: hot\nAutumn: yellow: leaves: cool" > ~/example.txt`

---
### Собираем байты

Применим команду `cut` к стандартному вводу `STDIN`, получаем первый байт, параметр = `-b`:

`echo "The sky was yellow as brass." | cut -b 1`

Несколько символов, укажем их позиции через запятую:

`echo "I looked at my watch; not eight o'clock." | cut -b 5,8,17`

Диапазон укажем через дефис:

`echo "Still I opened the gate, and put the petrol pump in readiness." | cut -b 1-7`

Если такой позиции нет в строке - выводится либо пустая строка, либо генерируется ошибка.

`echo "Still" | cut -b 1-1000`   
 _Вывод "Still"_

Можно указать только начало или конец диапазона:  

`echo "Still I opened the gate, and put the petrol pump in readiness." | cut -b 6-`  

Опять применим команду `cut` к стандартному вводу `STDIN`:  

`echo "Стренжерс ин ве найт..." | cut -b 1-9`
Вывод: Стре�
Почему? 
Другая кодировка, где символу отводится несколько бит
---
### Собираем символы

Для работы с позициями символов, вместо позиций байт, используйте -c вместо -b:

```shell
echo "Стренжерс ин ве найт..." | cut -c 1-9
```
Вывод: Стренжерс

Будем работать с файлом. Читаем диапазон байт строк файла:

```shell
cut -b 1-9 example.txt
```

Перенаправим вывод `cut` в команду `sort`. Что произошло? 

````shell
cut -b 1-9 example.txt | sort
````

Отсортируем вывод в обратном порядке:

```shell
cut -b 1-9 example.txt | sort -r
```
---
### Собираем столбцы

В тексте `"Winter: white: snow: frost"` мы использовали разделители `:`  
Разделители позволяют разделить строку на части, эти части называют **столбцами**, потому, что такие разделители используют, например, для записи таблиц в файл.  
Получим первый столбец для строки стандартного ввода, в качестве разделителя зададим пробел. 

```shell
echo "From the inn issued a smell of frying liver." | cut -d ' ' -f 1
```
Теперь прочитаем первый столбец нашего файла:  

```shell
cut -d ':' -f 1 example.txt
```

Несколько столбцов:  

```shell
cut -d ':' -f 1,2 example.txt
```

Диапазон столбцов:  

```shell
cut -d ':' -f 1-40 example.txt
```
---
### Что можно сделать с выводом текста 
**Сортируем**:  

```shell
cut -d ':' -f 1 example.txt| sort
```
**Обрабатываем**
Существует скриптовый язык `awk`, который применяется для обработки текста.  
Добавим, например, нумерацию строк.  

```shell
cut -d ':' -f 1 example.txt|  sort | awk '{print NR,$0}'
```
