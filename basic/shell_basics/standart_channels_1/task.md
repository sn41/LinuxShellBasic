# Canals

`В UNIX всё - файл`.  
Экран, клавиатура, сетевое соединение, устройство - доступ к любому элементу осуществляется так, словно это файл.
Что это означает? Как минимум:
- Его можно прочитать, и в него можно записать. Файл имеет потоки ввода и вывода. 
- Файл имеет местоположение, путь к нему в файловой системе.
- Файл можно создать, удалить. 
- Файл имеет права доступа. Кто-то может читать, кто-то может редактировать, кто-то может создать и удалить. 

Мы открываем терминал и вводим:    
`echo "Это сообщение"`  
Что произошло?  
Терминал иначе говоря командный процессор, (bash, например), получает строку, которую вы ввели, интерпретирует её, и начинает выполнять.  
`echo` - команда командного процессора. Она вызвана с параметром `"Это сообщение"`. Назначение этой команды - вывод строки. Куда?
В канал стандартного вывода. Сейчас строка выведена на экран. Это потому, что сейчас, по-умолчанию для команды echo стандартным выводом является экран консоли.

Запуская команды мы создаём процесс исполнения. Каждому процессу ядро назначает три коммуникационных канала:
- STDIN (стандартный ввод)
- STDOUT (стандартный вывод)
- STDERR (стандартная ошибка)

Процесс пользуется интерфейсом канала, чтобы отправить или получить сообщение.  
При этом процесс не знает, что подключено к этому каналу.  
А значит не может сделать ничего, чтобы подстроиться под это подключение.  

Для адресации используется модель UNIX, где каждый канал описывается числом, называемым `file dexcriptor`.
Для STDIN, STDOUT, STDERR назначены файловые дескрипторы 0, 1, 2.

Для большинства команд по умолчанию назначен ввод из STDIN, вывод в STDOUT, вывод ошибок в STDERR.

Теперь

Shell, командный процессор, интерпретирует символы `>`, `<`, `>>`, `|`   как команды перенаправления данных.

- Символ `<` соединяет STDIN с файлом,  
- Символы `>`, `>>` перенаправляют потоки вывода. 
  - `>` заменяет содержимое файла, 
  - `>>` добавляет данные к содержимому.  
  - `2>` чтобы перенаправить STDERR 
  - `>&` чтобы перенаправить и STDOUT и STDERR вместе.

-  Символ `|` (pipe - поток, труба), используется, для перенаправления STDOUT одной программы на STDIN другой.



Воспользуемся командной вывода сообщения `echo`, командой обрезки вывода `cat`, командой поиска `find`.  
 
 - В коммандной строке введите:   
 **echo "Это сообщение"**  
 _Вы увидите вывод на экран_ `Это сообщение`.
 - В коммандной строке введите:  
 **echo Это сообщение**  
 _Вы увидите вывод на экран_ `Это сообщение`.  
 Пока сделаем вывод от том, что в качестве STDIN команда echo использует экран консоли. 
 
 - Перенаправим вывод в файл mymessage (если такого нет, он будет создан):  
 **echo Это сообщение > /tmp/mymessage**  
 В каталоге `/tmp` был создан файл `mymessage`, и все строки которые вывела команда `echo` были записаны в него.
 
 - Перенаправим вывод в файл mymessage в домашнем каталоге:  
 **echo Это сообщение > ~/mymessage**  
 - Запустите файловый менеджер, убедитесь, что такой файл создан в домашнем каталоге, и посмотрите его содержимое.
 
 - Перенаправим вывод в файл mymessage в несуществующим каталоге:  
 **echo Это сообщение > ~/tmp/mymessage** 
 
 - Прочитаем содержимое файла `/tmp/mymessage`. Вывод содержимого перенаправим в файл в домашнем каталоге ~/mymessage1  
 **cat /tmp/mymessage > ~/mymessage1**
 - Посмотрите, что получилось.


`find` использует и STDOUT и STDERR, перенаправим STDERR в файл.
 Посмотрим на вывод ошибки, вызовем ошибку доступа (permission denied).
 **find / -name core**
 - Перенаправим поток сообщений об ошибках в файл.
 **find / -name core 2> ~/finderr**
 - Перенаправим потоки STDERR в ~/finderr, а STDOUT в ~/findmessage.
 **find / -name core > ~/findmessage 2> ~/finderr**
 - Перенаправим оба потока в никуда, в /dev/null
 **find / -name core >& /dev/null**

Перенаправим `STDOUT` команды просмотра процессов `ps` на `STDIN` команды фильтра строк `grep`. 
- Понаблюдаем стандартный вывод, выполните:
**ps -ef**
- Теперь отфильтруем строки, выполните:
**ps -ef|grep httpd**


## cut
Формат команды cut  
**cut**   _опции_   _путь_к_файлу_  
**путь_к_файлу** - опциональный параметр, путь к файлу, или нескольким файлам.
Если в качестве путь_к_файлу использовать прочерк, либо не указать ничего, 
команда будет использовать текст из стандартного ввода.  


**Опции**:  
**-b** (**--bytes=LIST**) — позиция вырезаемого байта, набора или диапазона байтов, счёт с 1.  
**-c** (**--characters=LIST**) — позиция вырезаемого символа, набора либо диапазона символов.  
**-d** (**--delimiter=DELIM**) — используемый разделитель вместо стандартного TAB.  
**-f** (**--fields=LIST**) — перечень полей для вырезания.  
**-s** (**--only-delimited**) — если была применена эта опция, cut не выводит строки, где нет разделителя.  
**--complement** — задает байты, символы или поля, которые останутся в файле или тексте из стандартного ввода. Все остальное будет вырезано.  
**--output-delimiter=STRING** — по умолчанию выходной разделитель соответствует входному. Эта опция позволяет задать другой выходной разделитель.  
**-z**, **--zero-terminated** — вместо символа новой строки разделителем будет **NULL**.

 
1. Создадим файл example.txt, чтобы использовать перенос строк, используем для `echo` параметр `-e` и заключим текст в кавычки:  
**echo -e "Winter: white: snow: frost\nSpring: green: grass: warm\nSummer: colorful: blossom: hot\nAutumn: yellow: leaves: cool"  ~/example.txt**  
 2. Применим команду `cut` к стандартному вводу `STDIN`, получаем первый байт, параметр = `-b`:  
 `echo "The sky was yellow as brass." | cut -b 1`
 3. Несколько символов, укажем их позиции через запятую:   
 `echo "I looked at my watch; not eight o'clock." | cut -b 5,8,17`
 4. Диапазон укажем через дефис:  
 `echo "Still I opened the gate, and put the petrol pump in readiness." | cut -b 1-7`  
 5. Если такой позиции нет в строке - выводится либо пустая строка, либо генерируется ошибка.
 `echo "Still" | cut -b 1-1000`   
 _Вывод "Still"_
 6. Можно указать только начало или конец диапазона:  
 `echo "Still I opened the gate, and put the petrol pump in readiness." | cut -b 6-`  
 7. Опять применим команду `cut` к стандартному вводу `STDIN`,:  
 `echo "Стренжерс ин ве найт..." | cut -b 1-9`
 Вывод: Стре�
 Почему? 
 Другая кодировка, где символу отводится несколько бит
 8. Для работы с позициями символов, вместо позиций байт, используйте -c вместо -b:
 `echo "Стренжерс ин ве найт..." | cut -c 1-9`
 Вывод: Стренжерс
 9. Будем работать с файлом. Читаем диапазон байт строк файла:  
 `cut -b 1-9 example.txt`
 10. Перенаправим вывод `cut` в команду `sort` 
 `cut -b 1-9 example.txt | sort`
 11. Отсортируем вывод в обратном порядке:
 `cut -b 1-9 example.txt | sort -r`
 12. В тексте `"Winter: white: snow: frost"` мы использовали разделители `:`  
 Разделители позволяют разделить строку на части, эти части называют **столбцами**, потому, что такие разделители используют, например, для записи таблиц в файл.  
 Получим первый столбец для строки стандартного ввода, в качестве разделителя зададим пробел.   
 `echo "From the inn issued a smell of frying liver." | cut -d ' ' -f 1`  
 13. Теперь прочитаем первый столбец нашего файла:  
 `cut -d ':' -f 1 example.txt`
 14. Несколько столбцов:  
 `cut -d ':' -f 1,2 example.txt`
 15. Диапазон столбцов:  
 `cut -d ':' -f 1-40 example.txt`
 16. Сортируем:  
 `cut -d ':' -f 1 example.txt| sort`
 17. Существует скриптовый язык `awk`, который применяется для обработки текста.  
 Добавим, например, нумерацию строк.  
 `cut -d ':' -f 1 example.txt|  sort | awk '{print NR,$0}'`


## Условное выполнение
Чтобы выполнить вторую команду только в случае успешного завершения первой, используется оператор `&&`  

>
> 1. Выведем на печать файл `example.txt`. Если операция будет успешной, удалим этот файл.
> `cat ~/example.txt && rm ~/example.txt`
> `Файл example.txt` удёлён
>

Чтобы выполнить вторую команду только в случае **не**успешного завершения первой, используется оператор `||`  
И можно использовать `\` чтобы разбить команду на несколько строк. 

>
> `cat ~/example.txt 2>/dev/null || echo "Такой файл отсутствует"`
>

## Переменные










