## cut

Эта команда выполняет разбиение строк входящего потока на фрагменты; 
затем требуемые фрагменты собираются в строку и помещаются в исходящий поток.
Фрагментами могут быть байты, символы или построки, полученные делением строки по разделителям.

Формат команды:  
cut {  -b List [  -n ] |  -c List |  -f List [  -s ] [  -d Character ] } [ File ... ]  

File - путь_к_исходным_файлам  - опциональный параметр, если он не задан, используется стандартный поток ввода. 

**Список опции  (в скобках - вариант написания)**:  

Опции разбиения строки на байты или символы - элементы на заданных позициях попадут в строку вывода. 
**(счёт позиций выполняется с единицы)**:  

| опция | вариант написания         | описание                                                 |
|-------|---------------------------|----------------------------------------------------------|
| -b    | --bytes=LIST              | выбираемые набор или диапазон позиций байтов             |
| -n    |                           | "не склеивать" байты, являющиеся частями разных символов |  
| -     | -                         | -                                                        |
| -c    | --characters=LIST         | выбираемые набор или диапазон позиций символов           |  
| -     | -                         | -                                                        |
| -d    | --delimiter=DELIM         | разделитель полей (по умолчанию **TAB**)                 |
| -f    | --fields=LIST             | выбираемые набор или диапазон полей                      |                                
| -s    | --only-delimited          | не выводить строки без разделителя. (Только вместе с -f) | 
| -     | -                         | -                                                        |
|       | --complement              | избранные подстроки, остальное отфильтровывается         |  
|       | --output-delimiter=STRING | выходной разделитель, по умолчанию равен входному        |  
| -z    | --zero-terminated         | вместо символа новой строки разделителем будет **NULL**  |

 
1. Создадим файл example.txt, чтобы использовать перенос строк, используем для `echo` параметр `-e` и заключим текст в кавычки:  
**echo -e "Winter: white: snow: frost\nSpring: green: grass: warm\nSummer: colorful: blossom: hot\nAutumn: yellow: leaves: cool"  ~/example.txt**  
 2. Применим команду `cut` к стандартному вводу `STDIN`, получаем первый байт, параметр = `-b`:  
 `echo "The sky was yellow as brass." | cut -b 1`
 3. Несколько символов, укажем их позиции через запятую:   
 `echo "I looked at my watch; not eight o'clock." | cut -b 5,8,17`
 4. Диапазон укажем через дефис:  
 `echo "Still I opened the gate, and put the petrol pump in readiness." | cut -b 1-7`  
 5. Если такой позиции нет в строке - выводится либо пустая строка, либо генерируется ошибка.
 `echo "Still" | cut -b 1-1000`   
 _Вывод "Still"_
 6. Можно указать только начало или конец диапазона:  
 `echo "Still I opened the gate, and put the petrol pump in readiness." | cut -b 6-`  
 7. Опять применим команду `cut` к стандартному вводу `STDIN`,:  
 `echo "Стренжерс ин ве найт..." | cut -b 1-9`
 Вывод: Стре�
 Почему? 
 Другая кодировка, где символу отводится несколько бит
 8. Для работы с позициями символов, вместо позиций байт, используйте -c вместо -b:
 `echo "Стренжерс ин ве найт..." | cut -c 1-9`
 Вывод: Стренжерс
 9. Будем работать с файлом. Читаем диапазон байт строк файла:  
 `cut -b 1-9 example.txt`
 10. Перенаправим вывод `cut` в команду `sort` 
 `cut -b 1-9 example.txt | sort`
 11. Отсортируем вывод в обратном порядке:
 `cut -b 1-9 example.txt | sort -r`
 12. В тексте `"Winter: white: snow: frost"` мы использовали разделители `:`  
 Разделители позволяют разделить строку на части, эти части называют **столбцами**, потому, что такие разделители используют, например, для записи таблиц в файл.  
 Получим первый столбец для строки стандартного ввода, в качестве разделителя зададим пробел.   
 `echo "From the inn issued a smell of frying liver." | cut -d ' ' -f 1`  
 13. Теперь прочитаем первый столбец нашего файла:  
 `cut -d ':' -f 1 example.txt`
 14. Несколько столбцов:  
 `cut -d ':' -f 1,2 example.txt`
 15. Диапазон столбцов:  
 `cut -d ':' -f 1-40 example.txt`
 16. Сортируем:  
 `cut -d ':' -f 1 example.txt| sort`
 17. Существует скриптовый язык `awk`, который применяется для обработки текста.  
 Добавим, например, нумерацию строк.  
 `cut -d ':' -f 1 example.txt|  sort | awk '{print NR,$0}'`